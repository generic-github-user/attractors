# AUTOGENERATED! DO NOT EDIT! File to edit: 00_attractor.ipynb (unless otherwise specified).

__all__ = ['Attractor', 'RouletteCurve']

# Cell

class Attractor:
    def __init__(self):
        pass

class RouletteCurve(Attractor):
    def __init__(self, center=[0, 0], num_sections=4, lengths=None, speeds=None, random_distribution='uniform'):
        """
        Create a new `RouletteCurve` object. This subclasses `Attractor` and describes a process where one or more line segments, connected end-to-end, rotate continuously about their pivots/endpoints. The length of each line segment and the speed at which it rotates are adjustable parameters.
        """
        super().__init__()
        self.random_distribution = getattr(np.random, random_distribution)
        self.rd = self.random_distribution
        self.center = np.array(center)
        self.rank = self.center.size
#         use rank?
        if lengths is None:
            lengths = np.random.normal(0, 1, num_sections)
        if speeds is None:
            speeds = np.random.normal(0, 1, num_sections)
        self.lengths = RouletteCurve.randomize_list(lengths).astype(float)
        self.speeds = RouletteCurve.randomize_list(speeds).astype(float)
        self.angles = np.random.normal(0, 2*math.pi)
        self.pivots = center + np.array([[0, sum(self.lengths[:i])] for i in range(1, len(self.lengths)+1)])
        self.pivots = self.pivots.astype(float)
        self.pivots_ = []
        print(self.pivots, True)
        self.points = []
        self.canvas = np.zeros([100, 100])
        self.position = 0

    def simulate(self, steps=1):
        for s in range(steps):
            last = self.pivots.copy()
#             for l in list(range(len(self.pivots)))[::-1]:
            gamma = 0
            num_pivots = len(self.pivots)
            for l in list(range(num_pivots)):
#             theta = 1 * self.speeds
                theta = 1 * self.speeds[l]
                rMatrix = [
                    [np.cos(theta), -np.sin(theta)],
                    [np.sin(theta), np.cos(theta)]
                ]
                rMatrix = np.array(rMatrix)#.swapaxes(0,2)
                offsets = self.center if l == 0 else last[l-1]#.copy() #?
                for f in list(range(l+1, num_pivots)):
    #                 print(s, rMatrix)
        #             print(self.pivots[:-1].shape)
    #                 offsets = np.concatenate([self.center[np.newaxis,...], self.pivots[:-1]], axis=0)
    #                 offsets=np.array(0)
    #                 len(self.pivots)-1
    #                 print(offsets)
        #             print(offsets.shape, rMatrix.shape, self.pivots.shape)
    #                 self.pivots[l] = (last[l] - offsets) @ rMatrix + offsets

    #                 func of t?
    #                 delta = (last[l] - offsets) @ rMatrix + offsets
                    delta = (rMatrix @ (self.pivots[f] - offsets)) + offsets# + gamma
    #                 print(delta)
                    gamma += delta
                    self.pivots[f] = delta
    #             self.points.append(np.clip(self.pivots[-1], 0, np.array(self.canvas.shape)))
            self.pivots_.append(self.pivots.copy())
            self.points.append(self.pivots[-1].copy())
        return self

    def render(self, recenter=True, zoom=None):
        cshape = np.array(self.canvas.shape)
        offset = cshape / 2
        if zoom is None:
            zoom = np.min(cshape / np.max(np.abs(self.points), axis=0)) * 0.5
            print(zoom)
#         for p in self.points.copy():
        for p in map(np.copy, self.points):
            p = p.astype(float)
            p *= zoom
            if recenter:
                p += offset
            p = np.clip(p, 0, np.array(self.canvas.shape)-1)
            x, y = p.astype(int)
            self.canvas[x, y] += 1
#         plt.style.use('fivethirtyeight')
        plt.style.use('classic')
        P = plt.imshow(np.flip(self.canvas.T, axis=0), interpolation='none')
        plt.grid('off')
        return P
#         return self

    @staticmethod
    def randomize_list(L):
        return np.array([self.rd(*x) if type(x) in [list, tuple] else x for x in L])